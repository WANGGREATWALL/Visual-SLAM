# 第2讲 初识SLAM

`王琛` | `2020/10/02`

[toc]

> **主要目标:** 本讲概括地介绍一个视觉 SLAM 系统的结构, 作为后续内容的大纲. 实践部分介绍环境搭建、程序基本知识, 最后完成一个 "Hello SLAM" 程序.
>
> 1. 理解一个视觉 SLAM 框架由哪几个模块组成, 各模块的任务是什么?
> 2. 搭建编程环境, 为开发和实验做准备;
> 3. 理解如何在 Linux 下编译并运行一个程序, 如果程序出了问题, 又该如何对它进行调试;
> 4. 掌握 cmake 的基本使用方法;

## 2.1 经典视觉SLAM框架

SLAM 需要一个完善的算法框架, 而经过研究者们长期的努力工作, 现有这个框架已经定型了.

![image-20201002173359361](https://i.loli.net/2020/10/03/7uov1EpH4TRChZ9.png)

视觉 SLAM 流程包括以下步骤:

1. 传感器信息读取. 在视觉 SLAM 中主要为相机图像信息的读取和预处理. 如果是在机器人中, 还可能有码盘、惯性传感器等信息的读取和同步;
2. **视觉里程计** (Visual Odometry, VO). 视觉里程计的任务是估算相邻图像间相机的运动, 以及局部地图的样子. VO 又称为前端 (Front End);
3. **后端优化** (Optimization). 后端接受不同时刻视觉里程计测量的相机位姿, 以及回环检测的信息, 对它们进行优化, 得到全局一致的轨迹和地图. 由于接在 VO 之后, 又称为后端 (Back End);
4. **回环检测** (Loop Closing). 回环检测判断机器人是否到达过先前的位置. 如果检测到回环, 它会把信息提供给后端进行处理;
5. **建图** (Mapping). 它根据估计的轨迹, 建立与任务要求对应的地图;

经典的视觉 SLAM 框架是过去十几年的研究成果. 这个框架本身及其所包含的算法已经基本定型, 并且已经在许多视觉程序库和机器人程序库中提供. 依靠这些算法, 我们能够构建一个视觉 SLAM 系统, 使之在正常的工作环境里实时定位与建图. 因此, 我们说, **如果把工作环境限定在静态、刚体、光照变化不明显、没有人为干扰的场景**, 那么这个 SLAM 系统是相当成熟的了.

### 2.1.1 视觉里程计

视觉里程计关心的是**相邻图像**之间的相机运动, 为了能通过图像数据定量地估计相机运动, 必须先了解相机与空间点的几何关系. VO 能够通过相邻帧间的图像估计相机运动, 并恢复场景的空间结构. 称它为"里程计"是因为它和实际的里程计一样, 只计算相邻时刻的运动, 而**和再往前的过去信息没有关联**. 在这一点上, VO 就像一种**只有短时间记忆**的物种.

现在, 假定我们已有了一个视觉里程计, 估计了两张图像间的相机运动. 那么只要把相邻时刻的运动"串起来", 即构成了机器人的运动轨迹, 从而解决了定位问题. 另一方面, 我们根据每个时刻的相机位置, 计算出各像素对应的空间点的位置, 就得到了地图. 然而, 仅通过视觉里程计来估计轨迹, 将不可避免地出现累积**漂移** (Accumulating Drift).

为了解决漂移问题, 我们还需要两种技术: 后端优化和回环检测. 回环检测负责把"**机器人回到原始位置**"的事情检测出来, 而后端优化则根据该信息, 校正整个轨迹的形状.

### 2.1.2 后端优化

笼统地说, 后端优化主要指处理 SLAM 过程中噪声的问题. 除了解决"如何从图像估计出相机运动"之外, 我们还要关心这个估计带有多大的噪声, 这些噪声是如何从上一时刻传递到下一时刻的, 而我们又对当前的估计有多大的自信. **后端优化要考虑的问题, 就是如何从这些带有噪声的数据中估计整个系统的状态, 以及这个状态估计的不确定性有多大**——这称为最大后验概率估计 (Maximum-a-Posteriori, MAP).

在视觉 SLAM 中, 前端和计算机视觉研究领域更为相关, 比如**图像的特征点提取与匹配等**, 后端则主要是**滤波与非线性优化算法**.

从历史意义上来说, 现在我们称为后端优化的部分, 很长一段时间直接被称为"SLAM 研究". 早期的 SLAM 问题是一个状态估计问题——正是后端优化要解决的东西. 在最早提出 SLAM 的一系列论文中, 当时的人们称它为"空间状态不确定性的估计" (Spatial Uncertainty). 虽然有一些晦涩, 但也确实反映出了 SLAM 问题的本质: **对运动主体自身和周围环境空间不确定性的估计**. 为了解决 SLAM 问题, 我们需要状态估计理论, 把定位和建图的不确定性表达出来, 然后**采用滤波器或非线性优化, 估计状态的均值和不确定性 (方差)**. 

### 2.1.3 回环检测

如果有某种手段, 让机器人知道"回到了原点"这件事, 或者把"原点"识别出来, 我们再把位置估计值"拉"过去, 就可以消除漂移了. 这就是所谓的回环检测. 为了实现回环检测, 我们需要让机器人具有识别到过的场景的能力. 可以通过判断图像间的相似性来完成回环检测. 这一点和人是相似的. 当我们看到两张相似的图片时, 容易辨认它们来自同一个地方. 如果回环检测成功, 可以显著地减小累计误差. **所以视觉回环检测实质上是一种计算图像数据相似性地算法**. 由于图像的信息非常丰富, 使得正确检测回环的难度降低了不少.

### 2.1.4 建图

对于地图, 有太多需求和针对性的解决方法, 因此, 相比于前面提到的视觉里程计、回环检测和后端优化, 建图并没有一个固定的形式和算法. 一组空间点的集合可以称为地图, 一个漂亮的 3D 模型亦是地图, 一个标记着城市、村庄、铁路、河道的图片还是地图. 地图的形式随 SLAM 的应用场合而定. **大体上讲, 可以分为度量地图与拓扑地图两种.**

- **度量地图** (Metric Map)
  度量地图**强调精确地表示地图中物体的位置关系**, 通常用稀疏 (Sparse) 与稠密 (Dense) 对其分类. 稀疏地图进行了一定程度的抽象, 并不需要表达所有的物体. 例如, 我们选择一部分有代表意义的东西称之为路标 (Landmark), 那么一张稀疏地图就是由路标组成的地图, 而不是路标的部分就可以忽略掉. 相对地, 稠密地图着重于建模所有看到的东西. 对于定位来说, 稀疏路标地图就足够了. 而用于导航时, 则往往需要稠密的地图 (否则撞上两个路标之间的墙怎么办?) 稠密地图通常按照某种分辨率, 由许多个小块组成. 对于二维度量地图是许多个小格子 (Grid), 而对于三维度量地图则是许多小方块 (Voxel).
- **拓扑地图** (Topological Map)
  相比于度量地图的精确性, 拓扑地图则更强调地图元素之间的关系. 拓扑地图是一个图 (Graph), 由节点和边组成, **只考虑节点间的连通性**, 例如 A、B 点是连通的, 而不考虑如何从 A 点到达 B 点. 它放松了地图对精确位置的需要, 去掉了地图的细节问题, 是一种更为紧凑的表达方式. 然而, 拓扑地图不擅长表达具有复杂结构的地图. 如何对地图进行分割形成结点与边, 又如何使用拓扑地图进行导航与路径规划, 仍是有待研究的问题.

## 2.2 SLAM问题的数学表述

用 $x_1,x_2,...x_K$ 代表离散时刻 $t=1,2,...K$ 机器人小萝卜 (SLAM 系统) 的自身位置, 假设地图是由许多个路标 (Landmark) 组成的, 而每个时刻, 传感器会测量到一部分路标点, 得到它们的观测数据. 不妨设路标一共有 $N$ 个, 用 $y_1,y_2,...y_N$ 表示它们. 在这样的设定中, "小萝卜携带着传感器在环境中运动", 由如下两件事情描述:

1. 什么是**运动**? 我们要考虑从 $k-1$ 时刻到 $k$ 时刻, 小萝卜的位置 $x$ 是如何变化的;
2. 什么是**观测**? 假设小萝卜在 $k$ 时刻于 $x_k$ 处探测到了某一个路标 $y_j$, 我们要考虑这件事情是如何用数学语言来描述的.

先来看运动. 通常机器人会携带一个测量自身运动的传感器, 比如说码盘或惯性传感器. 这个传感器可以测量有关运动的读数, 但不一定直接就是位置之差, 还可能是加速度、角度等信息. 然而无论是什么传感器, 我们都能使用一个通用的、抽象的数学模型:
$$
x_k=f(x_{k-1},u_k,\omega_k)
$$
式中, $u_k$ 是运动传感器的读数 (有时也叫输入), $\omega_k$ 为噪声. 上面这个通用方程就是**运动方程**.

与运动方程相对应, 还有一个**观测方程**. 观测方程描述的是: 在位置 $x_k$ 处看到某个路标 $y_j$, 产生了一个观测数据 $z_{k,j}$. 同样可以用一个通用的抽象函数 $h$ 来描述这个关系:
$$
z_{k,j}=h(y_j,x_k,v_{k,j})
$$
这里, $v_{k,j}$ 是这次观测里的噪声. 由于观测所用的传感器形式更多, 这里的观测数据 $z$ 以及观测方程 $h$ 也有许多不同的形式. 

运动方程和观测方程针对不同的传感器会有不同的参数化形式, 两者描述了最基本的 SLAM 问题: **当知道运动测量的读数 $u$, 以及传感器的读数 $z$ 时, 如何求解定位问题 (估计 $x$) 和建图问题 (估计 $y$)?** 这时我们就把 SLAM 问题建模成了一个状态估计问题: **如何通过带有噪声的测量数据, 估计内部的、隐藏着的状态变量？**

状态估计问题的求解, 与两个方程的具体形式, 以及**噪声服从哪种分布**有关. 按照运动和观测方程是否线性, 噪声是否服从高斯分布进行分类, 分为**线性/非线性**和**高斯/非高斯**系统. 其中线性高斯系统 (Linear Gaussian, LG 系统) 是最简单的, 它的无偏的最优估计可以由**卡尔曼滤波器 (Kalman Filter, KF)** 给出. 而在复杂的非线性非高斯系统 (Non-Linear Non-Gaussian, NLNG 系统) 中, 我们会使用**拓展卡尔曼滤波器** (Extended Kalman Filter, EKF) 和**非线性优化**两大类方法去求解. 直至 21 世纪早期, 以 EKF 为主的滤波器方法在 SLAM 中占据了主导地位. 我们会在工作点处把系统**线性化**, 并以**预测—更新**两大步骤进行求解 (见第 10 讲). 最早的实时视觉 SLAM 系统就是基于 EKF 开发的. 随后为了克服 EKF 的缺点 (例如线性化误差和噪声高斯分布假设), 人们开始使用**粒子滤波器** (Particle Filter) 等其他滤波器, 乃至使用**非线性优化的方法**. 时至今日, 主流视觉 SLAM 使用以**图优化** (Graph Optimization) 为代表的优化技术进行状态估计. 我们认为优化技术已经明显优于滤波器技术, 只要计算资源允许, 通常都偏向于使用优化方法 (见第 10 讲和第 11 讲).

三维空间中的位姿是一个 6 自由度的 (包括 3 个轴的旋转和平移), 第 3 讲和第 4 讲将介绍如何表达和优化这个 6 自由度的位姿. 随后我们要说明在视觉 SLAM 中, **观测方程如何参数化**. 换句话说, 空间中的路标点是如何投影到一张照片上的. 这需要解释相机的成像模型, 我们将在第 5 讲介绍. 最后, 当知道了这些信息, 怎么求解上述方程? 这需要非线性优化的知识, 是第 6 讲的内容.

## 2.3 实践: 编程基础

### 2.3.1 安装Linux系统

- 我们先来搭建本书所需的实验环境. 作为一本面向初学者的书, 我们使用 Ubuntu 作为开发环境. 在 Linux 的各大发行版中, Ubuntu 及其衍生版本一直享有对用户友好的美誉. Ubuntu 是一个开源操作系统, 它的系统和软件可以在官方网站 ([http://cn.ubuntu.com](http://cn.ubuntu.com)) 免费下载, 并且提供了详细的安装方式说明. 同时清华、中科大等国内各大高校也提供
  了 Ubuntu 软件源, 使软件的安装十分便捷. 对于初学者, 建议你使用和我们一样的环境: Ubuntu 14.04. 如果你想试试其他口味, 那么 Ubuntu 16.04、Ubuntu Kylin、Debian 7/8 和 Linux Mint 17/18 也是不错的选择. 我们保证书中所有代码在 Ubuntu 14.04 下经过了良好的测试;  
- Ubuntu 系统的安装自行解决;
- 需要说明的是, 虚拟机软件对外部硬件的支持往往不够好, 如果希望使用实际的传感器 (双目、Kinect 等), 则建议使用双系统来安装 Linux;
- 不要在 Ubuntu 的用户界面上花费太多时间!

### 2.3.2 Hello SLAM

在 Linux 中, 程序是一个**具有执行权限的文件**. 它可以是一个脚本, 也可以是一个二进制文件, 不过我们不限定它的后缀名 (不像 Windows 那样需要指定成 `.exe` 文件). 常用的 `cd`、`ls` 等命令, 就是位于 `/bin` 目录下的可执行文件. 而对于其他地方的可执行程序, 只要它有可执行权限, 那么当我们在终端中输入程序名时, 它就会运行. 用 gedit 或 Vim 编写下面的 C++ 示例代码并保存到注释列出的路径下:

```c++
//slambook/ch2/helloSLAM.cpp
using namespace std;
int main(int argc,char** argv){
	cout << "Hello SLAM!" << endl;
    return 0;
}
```

用**编译器** g++ (g++ 是一个 C++ 编译器) 把它编译成一个可执行文件. 输入:

```c
g++ helloSLAM.cpp
```

如果机器上出现 "command not found" 则说明你可能还没有安装 g++, 可用如下命令安装:

```c
sudo apt-get install g++
```

编译完成后, 当前目录会多出一个 `a.out` 文件, 而且它具有执行权限 (终端里颜色不同). 当我们输入 `./a.out` 即可运行此程序:

```c
% ./a.out
Hello SLAM!
```

### 2.3.3 使用cmake

理论上说, 任意一个 C++ 程序都可以用 g++ 来编译. 但当程序规模越来越大时, 一个工程可能有许多个文件夹和源文件, 这时输入的编译命令将越来越长. 通常一个小型 C++ 项目可能含有十几个类, 各类间还存在着复杂的依赖关系. 其中一部分要**编译成可执行文件**, 另一部分**编译成库文件**. 如果仅靠 g++ 命令, 我们需要输入大量的编译指令, 整个编译过程会变得异常烦琐. 因此, 对于 C++ 项目, 使用一些**工程管理工具**会更加高效. 在历史上工程师们曾使用 `makefile` 进行自动编译, 但下面要谈的 cmake 比它更加方便. 并且我们会看到后面提到的大多数库都使用 cmake 来管理源代码.
在一个 cmake 工程中, 我们会用 cmake 命令生成一个 makefile 文件, 然后, 用 make 命令根据这个 makefile 文件的内容编译整个工程. 读者可能还不知道 makefile 是什么东西, 不过没关系, 我们会通过例子来学习. 仍然以上面的 `helloSLAM.cpp` 为例, 这次我们不是直接使用 g++, 而是用 cmake 来制作一个工程, 然后再编译它. 在 `slambook/ch2/` 中新建一个 `CMakeLists.txt` 文件, 内容如下:

```txt
#slambook/ch2/CMakeLists.txt
cmake_minimum_required( VERSION 2.8 )

# 声明一个 cmake 工程
project( HelloSLAM )

# 添加一个可执行程序
# 语法: add_executable( 程序名 源代码文件 )
add_executable( helloSLAM helloSLAM.cpp )
```

`CMakeLists.txt` 文件用于告诉 cmake 我们**要对这个目录下的文件作什么事情**. `CMakeLists.txt` 文件的内容需要遵守 cmake 的语法. 这个示例中, 我们演示了最基本的工程: 指定一个工程名和一个可执行程序. 根据注释, 读者应该理解每句话做了些什么.

现在, 在当前目录下 (`slambook/ch2/`), 调用 cmake 对该工程进行分析:

```txt
cmake .
```

cmake 会输出一些编译信息, 然后在当前目录下生成一些中间文件, 其中最重要的就是 `MakeFile`. 由于 `MakeFile` 是自动生成的, 我们不必修改它. 现在, 用 make 命令对工程进行编译:

```cmake
% make
Scanning dependencies of target helloSLAM
[100%] Building CXX object CMakeFiles/helloSLAM.dir/helloSLAM.cpp.o
Linking CXX executable helloSLAM
[100%] Built target helloSLAM
```

编译过程中会输出一个编译进度. 如果顺利通过, 我们就可以得到在 `CMakeLists.txt` 中声明的那个可执行程序 helloSLAM. 执行它:

```cmake
% ./helloSLAM
Hello SLAM!
```

因为我们并没有修改源代码, 所以得到的结果和之前是一样的. 请读者想想这种做法和之前直接使用 g++ 编译的区别. 这次我们用 cmake-make 的做法, cmake 过程处理了工程文件之间的关系, 而 make 过程实际调用了 g++ 来编译程序. 虽然这个过程中多了调用 cmake 和 make 的步骤, 但我们**对项目的编译管理工作, 从输入一串 g++ 命令变成了维护若干个比较直观的 `CMakeLists.txt` 文件**, 这将明显降低维护整个工程的难度. 比如想新增一个可执行文件, 只需在 `CMakeLists.txt` 中添加一行 `add_executable` 命令即可, 而后续的步骤是不变的. cmake 会帮我们解决代码的依赖关系, 而无须输入一大串 g++ 命令.

现在这个过程中唯一让我们不满的是, cmake 生成的中间文件还留在我们的代码文件当中. 当想要发布代码时, 我们并不希望把这些中间文件一同发布出去. 这时我们还需要把它们一个个删除, 十分不便. 一种更好的做法是让这些中间文件都放在一个中间目录中, 在编译成功后, 把这个中间目录删除即可. 所以, 更常见的编译 cmake 工作的做法如何:

```cmake
mkdir build
cd build
cmake ..
make
```

我们新建了一个中间文件夹 `build`, 然后进入 `build` 文件夹, 通过 `cmake ..` 命令对上一层文件夹, 也就是代码所在的文件夹进行编译. 这样, cmake 产生的中间文件就会生成在 `build` 文件夹中, 与源代码分开. 当发布源代码时, 只要把 `build` 文件夹删掉即可.

### 2.3.4 使用库

在一个 C++ 工程中, 并不是所有代码都会编译成可执行文件. **只有带有 `main` 函数的文件才会生成可执行程序**. 而另一些代码, 我们只想把它们打包成一个东西, 供其他程序调用. 这个东西叫作**库**.

一个库往往是许多算法、程序的集合. 例如, OpenCV 库提供了许多计算机视觉相关的算法, 而 Eigen 库提供了矩阵代数的计算. 因此, 我们要学习如何使用 cmake 生成库, 并且使用库中的函数. 现在书写如下 `libHelloSLAM.cpp` 文件:

```c++
//slambook/ch2/libHelloSLAM.cpp
//这是一个库文件
#include <iostream>
using namespace std;
void printHello(){
	cout << "Hello SLAM" << endl;
}
```

这个库提供了一个 `printHello` 函数, 调用此函数讲输出一条信息. 但是它没有 `main` 函数, 这意味着这个库中没有可执行文件. 我们在 `CMakeLists.txt` 里加上如下内容:

```cmake
add_library( hello libHelloSLAM.cpp )
```

这条命令告诉 cmake, 我们想把这个文件**编译成一个叫作"hello"的库**. 然后和上面一样, 使用 cmake 编译整个工程:

```cmake
cd build
cmake ..
make
```

这时, 在 `build` 文件夹中就会生成一个 `libhello.a` 文件, 这就是我们得到的库. 在 Linux 中, 库文件分成**静态库**和**共享库**两种. 静态库以 `.a` 作为后缀名, 共享库以 `.so` 结尾. 所有库都是一些函数打包后的集合, 差别在于**静态库每次被调用都会生成一个副本, 而共享库则只有一个副本, 更省空间.** 如果想生成共享库而不是静态库, 只需使用以下语句即可:

```cmake
add_library(hello_shared SHARED libHelloSLAM.cpp)
```

此时得到的文件就是 `libhello_shared.so` 了. 

库文件是一个压缩包, 里面有**编译好的二进制函数.** 不过如果仅有 `.a` 或 `.so` 库文件, 那么我们并不知道里面的函数到底是什么, 调用的形式又是什么样. 为了让别人 (或者自己) 使用这个库, 我们需要提供一个头文件, 说明这个库里都有些什么. 因此, 对于库的使用者, **只要拿到了头文件和库文件, 就可以调用这个库了.** 下面编写 libhello 的头文件:

```c
//slambook/ch2/libHelloSLAM.h

#ifndef LIBHELLOSLAM_H_
#define LIBHELLOSLAM_H_
void printHello();
#endif
```

这样, 根据这个文件和我们刚才编译得到的库文件, 就可以使用 `printHello` 函数了. 下面写一个可执行程序来调用这个简单的函数:

```c
//slambook/ch2/useHello.cpp
#include "libHelloSLAM.h"
int main( int argc, char** argv ){
	printHello();
    return 0;
}
```

然后在 `CMakeLists.txt` 中添加一个可执行程序的生成命令, **链接**到刚才使用的库上:

```cmake
add_executable( useHello useHello.cpp )
target_link_libraries( useHello hello_shared )
```

通过这两行语句, useHello 程序就能顺利使用 hello_shared 库中的代码了. 这个小例子演示了如何生成并调用一个库. **对于他人提供的库**, 我们也可以用同样的方式对它们进行调用, 整合到自己的程序中. 

除了已经演示的功能之外, cmake 还有许多语法和选项, 这里不一一列举了. 习题中包含了一些 cmake 的阅读材料. 回顾一下我们之前做了哪些事:

1. 首先, 程序代码由头文件和源文件组成;
2. 带有 `main` 函数的源文件编译成可执行程序, 其他的编译成库文件;
3. 如果可执行程序想调用库文件中的函数, 它需要参考该库提供的头文件, 以明白调用的格式. 同时, 要把可执行程序**链接**到库文件上.

### 2.3.5 使用IDE

`Kdevelop` 的优点列举如下:

1. 支持 cmake 工程;
2. 对 C++ 支持较好 (包括 11 标准). 有高亮、跳转、补全等功能. 能自动排版代码;
3. 能方便地看到各个文件和目录树;
4. 有一键编译、断点调试等功能;
5. 无需付费.

## 2.4 习题

1. `g++` 命令有哪些参数? 怎么填写参数可以更改生成的程序文件名?
2. 使用 `build` 文件夹来编译 cmake 工程, 然后在 `Kdevelop` 中试试;
3. 如果忘了把库链接到可执行程序上, 编译会报错吗? 报什么错?
4. 阅读《cmake 实践》, 了解 cmake 的其他语法;
5. 完善 hello SLAM 小程序, 把它做成一个小程序库, 安装到本地硬盘中. 然后, 新建一个工程, 使用 find_package 找这个库并调用;
6. 寻找其他 cmake 教学材料, 深入了解 cmake, 例如 [https://github.com/TheErk/CMake-tutorial](https://github.com/TheErk/CMake-tutorial);
7. 找到 `Kdevelop` 的官网, 看看它还有哪些特性;
8. 尝试学习 `Vim`, 试试 `Kdevelop` 的 `Vim` 编辑功能;